# -*- coding: utf-8 -*-
"""question_2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_pMBAf8Q-n79RbRZkr1eXteE6aZdQgp4
"""

import numpy as np
import tensorflow as tf

"""
## Convolution Operations with Different Parameters

This notebook implements a convolution operation on a **5×5 input matrix** using a **3×3 kernel** with different stride and padding configurations.

### Input Matrix:
The given **5×5 matrix**:

```
[[ 1,  2,  3,  4,  5],
 [ 6,  7,  8,  9, 10],
 [11, 12, 13, 14, 15],
 [16, 17, 18, 19, 20],
 [21, 22, 23, 24, 25]]
```

### Kernel:
The given **3×3 kernel**:

```
[[ 0,  1,  0],
 [ 1, -4,  1],
 [ 0,  1,  0]]
```

We will perform convolutions with the following configurations:
- **Stride = 1, Padding = 'VALID'**
- **Stride = 1, Padding = 'SAME'**
- **Stride = 2, Padding = 'VALID'**
- **Stride = 2, Padding = 'SAME'**

The output feature maps for each case will be printed.
"""

# Define the 5x5 input matrix
input_matrix = np.array([[ 1,  2,  3,  4,  5],
                         [ 6,  7,  8,  9, 10],
                         [11, 12, 13, 14, 15],
                         [16, 17, 18, 19, 20],
                         [21, 22, 23, 24, 25]], dtype=np.float32)

# Define the 3x3 kernel
kernel = np.array([[ 0,  1,  0],
                   [ 1, -4,  1],
                   [ 0,  1,  0]], dtype=np.float32)

"""We apply convolution using NumPy (manual method)

*   Extracts regions from the input matrix matching the kernel size.
*   Multiplies element-wise with the kernel.
*   Sums the values to produce the feature map.




"""

def convolve2D(image, kernel, stride, padding):
    kernel_size = kernel.shape[0]

    # Apply padding if needed
    if padding == 'SAME':
        pad_size = kernel_size // 2
        padded_image = np.pad(image, pad_size, mode='constant', constant_values=0)
    else:
        padded_image = image

    output_size = ((padded_image.shape[0] - kernel_size) // stride) + 1
    output = np.zeros((output_size, output_size))

    for i in range(0, output_size * stride, stride):
        for j in range(0, output_size * stride, stride):
            region = padded_image[i:i+kernel_size, j:j+kernel_size]
            output[i//stride, j//stride] = np.sum(region * kernel)

    return output

# Compute convolutions with different parameters
outputs_numpy = {
    "Stride 1, Padding VALID": convolve2D(input_matrix, kernel, stride=1, padding='VALID'),
    "Stride 1, Padding SAME": convolve2D(input_matrix, kernel, stride=1, padding='SAME'),
    "Stride 2, Padding VALID": convolve2D(input_matrix, kernel, stride=2, padding='VALID'),
    "Stride 2, Padding SAME": convolve2D(input_matrix, kernel, stride=2, padding='SAME')
}

# Print NumPy outputs
for key, value in outputs_numpy.items():
    print(f"{key}:\n{value}\n")

"""We apply convolution using TensorFlow/Keras (optimized method)

*   Uses tf.nn.conv2d(), which:
*   Applies a sliding window over the input.
*   Performs element-wise multiplication.
*   Computes the sum to get the output.


"""

def perform_tf_convolution(input_matrix, kernel, stride, padding):
    # Reshape input and kernel for TensorFlow compatibility
    input_tensor = tf.constant(input_matrix, shape=[1, 5, 5, 1], dtype=tf.float32)
    kernel_tensor = tf.constant(kernel, shape=[3, 3, 1, 1], dtype=tf.float32)

    # Perform 2D convolution
    output = tf.nn.conv2d(input_tensor, kernel_tensor, strides=[1, stride, stride, 1], padding=padding.upper())

    return tf.squeeze(output).numpy()  # Convert tensor to NumPy array

# Compute convolutions with different parameters
outputs_tf = {
    "Stride 1, Padding VALID": perform_tf_convolution(input_matrix, kernel, stride=1, padding='VALID'),
    "Stride 1, Padding SAME": perform_tf_convolution(input_matrix, kernel, stride=1, padding='SAME'),
    "Stride 2, Padding VALID": perform_tf_convolution(input_matrix, kernel, stride=2, padding='VALID'),
    "Stride 2, Padding SAME": perform_tf_convolution(input_matrix, kernel, stride=2, padding='SAME')
}

# Print TensorFlow/Keras outputs
for key, value in outputs_tf.items():
    print(f"{key}:\n{value}\n")